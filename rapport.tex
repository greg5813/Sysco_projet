\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage[left=3cm,right=3cm,top=4cm,bottom=4cm]{geometry}
\pagestyle{plain}

\title{Projet de Systèmes Concurrents}
\author{Jorge Gutierrez \& Grégoire Martini}
\date{25 Janvier 2016}

\begin{document}
\maketitle

\bigskip
\bigskip
\bigskip
\tableofcontents
\newpage


\section{Etape 1}

On doit implanter le service de gestion d'objets partagés répartis. Dans cette première version, les 
SharedObject sont utilisés explicitement par les applications. \\

Plusieurs applications peuvent accéder de façon concurrente au même objet, ce qui nécessite de mettre en 
œuvre un schéma de synchronisation globalement cohérent pour le service que l'on implante.
On suppose que chaque application voulant utiliser un objet en récupère une référence (à un SharedObject) en 
utilisant le serveur de nom. On ne gère pas le stockage de référence (à des objets partagés) dans des objets partagés.

\subsection{Coté client}
\subparagraph{Classe Client}
\subparagraph{Classe SharedObject}

\subsection{Coté serveur}
\subparagraph{Classe Server}
\subparagraph{Classe ServerObject}


\clearpage
\section{Etape 2}

\clearpage
\section{Etape 3}

On doit  implanter un générateur de stub, destiné à soulager le programmeur de l'utilisation explicite des SharedObject. \\

La classe métier et l'interface de l'objet à partagé doivent être fournis par le programmeur.\\
Le générateur de stub est la classe StubGenerator. On lui passe en argument le nom de la classe métier dont on veut le stub et celui-ci génère le code java du stub et l'écrit dans le fichier nomdeclasse\_ stub.java. La compilation de ce dernier est laissé au programmeur.\\

Le stub étends la classe SharedObject et implémente l'interface de l'objet à partager ainsi que la classe Serializable.
Il contient un constructeur qui est celui de SharedObject et l'ensemble des méthodes publiques de la classe métier.
Il gère aussi les annotations @Read and @Write qui permettent de soulager le programmeur de la gestion explicite des verrous sur l'objet partagé dans son application. Il lui suffit d'annoter les méthodes de la classe métier selon qu'elles modifient (@Write) ou utilisent simplement l'état (@Read) de l'objet. \\

On utilise la classe File qui permet de créer un nouveau fichier et la classe FileWriter qui permet d'écrire dans un fichier. Le code générer est stocké dans un StringBuffer avant d'être écrit dans le fichier.\\
Toute l'architecture du stub est écrite dans des chaines de caractères statique et seules les parties dépendantes de la classe dont on génère le stub telles que le nom des méthodes ou des paramètres est récupérés au moment opportun.\\
 On utilise l'introspection de Java pour accéder à la classe métier. Attention, l'utilisation de la méthode getParameter pour récupérer les paramètres d'une méthode nécessite l'utilisation de Java 8.

\clearpage
\section{Etape 4}



\end{document}          
